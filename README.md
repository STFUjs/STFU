
STFU(0)
<hr>


<hr>

<font size="8in">
STFU: STANDARD TEXT FORMAT - UNIVERSAL
</font>


<pre>

<H1>STFU: STFUjs, STFU7 + "STFU8", STFUf, & STFU*</H1>

<h1>STFU: Standard Text Format - Universal</h1>

STFU has a variety of matching formats that Accurately Represent all forms of communication and Conceptual Representation.

<h1>STFU & STFUjs</h1>
<h2>STFU</h2>
STFU Accurately represents ALL knowledge and conceptualization in a simple and <b>Standard Text Format - Universal</b>.

In any natural language or technical representation, concepts are related to concepts by other concepts...

In any form, the structure of communication is an attempt to convey concepts.

Most natural languages, be them spoken or written or graphical or gesture, lack sufficient effective structure and are inefficient. Technical representations are lacking.

STFU combines all these requirements for Accurate Representation into one <b>effective</b> form!

STFU's STFU7 + "STFU8", STFUf, & STFU* are exhaustive formal standards.

<h2>STFU in ANY Text</h2>
Most communication uses some form of text or structure, STFU can be used anywhere!

<h3>@(@) Context</h3>
@() is the general form of a Context

@(@) is the Context accessable somewhere

@(My'Concept'TrE3@mysite.tld)

Every @(@) Context is inside the the Universal Tree. In the more sophisticated !()(), the structure is more explicit.

<h3>STFU's General Form: @(@) Context</h3>

STFU uses one standard form, an indicator Symbol with a Set of Turns ("path") and a Set of Slots (information).

@(@)()

The first expansion includes the full Context:

@(intro@stfu.site)

This is the parts "Entity Context" [at] "Host Context" 

The Host Context has its own STFU Context @(@host.tld) that's inside the Universal Context.

The Host Context can be implicit @(this'part) inside some "text", but the fully formed @(demo'this'part@stfu.site) is preferred.

A Context exists at any level of the Universe.

An "Entity Context" can be included, such as your @(name@my.tld)

Any Context has any diversity of sub contexts, so you can use @(me'stuff@my.tld) in the Universal Tree of Turns.

The Context can 
@(pet'toys'3@my.tld) have named or numeric indexes in the Turns, and references to other contexts.

Each Context can have lots of stuff inside, and you Declare how it is presented!

Inside any Context,

(Turns'in'Trees'4'5)((Slots'Slots)'oR'(3'2'more'1'turns)(aAzZ-_-_)'(indexed)(Slots))

Symbol ' is used similar to [,] or {,} in either Turns or ()() named/indexed or () unnamed Slots.

() and ()() both use the same symbol because it gets through HTTP correctly. (See below.)

<h3>@(@)() Associative Reference</h3>

Because every @(@) Context of STFU's Universal Context includes the Tree of Turns and the information in that Context, inter-relations of Concepts are extremely easy!

All Structures of Representation have their Tree of Turns and their information in Slots.

Concepts are represented by information in Slots.

A Slot can have an Associative Reference:

@(intro@stfu.site)(@(pet@stfu.site)(likes))

This Inter-Associative Reference is available anywhere, inside the same Context or between any Concepts anywhere!

@(me'stuff'pet'toys'"Green Thing"@my.tld)(@(pet'toys'3@my.tld))(same))

The Associative Reference can be a simple text or collection of bits or a Declaration.

@(@)(@(@)(*(demo'refs@stfu.site)'(how)(345))


<h2>@(@)(@(@)()) The Universe, Referenced</h2>
<h3>STFU in Texts</h3>
Anywhere a Concept may be presented, a STFU Context can Accurately Represent it and the Concept's Inter-Association to other Concepts.

@(intro'Concepts@stfu.site) is Referenced

@(intro'Concepts@stfu.site)(includes) is Referenced Accurately

<h3>Finding @(@) Contexts in Text</h3>
Finding @(@) Contexts is easy!

Because the pattern @( is rare, as is !() as is the @<script>TSixNow();</script>(turn'turn@your.tld)({any}) Context with time, finding @(@) Contexts is easy!

It is easiest to search for the @ character followed by a ( Context or a 6 number "ascii" Time and ( in the same pattern:

@(you@your.tld)
@(you'stuff'ğŸ§ @your.tld)

Or with a specific Time:

@t1m3rS(you'stuff'ğŸ§ @your.tld)

Or with information:

@(you@your.tld)(~(refs)(1)'(my'type)(s2)'*(@(demo'type@stfu.site))

Or an Associative Reference:

@(you'stuff'ğŸ§ @your.tld)(@t1m3rS(you'stuff'ğŸ§ @your.tld)(includes))

Combined:
@<script>TSixNow();</script>(You'turn@your.tld)(@t1m3rS(you'stuff'ğŸ§ @your.tld)(saw))

The optional initial Time is very important!

The @(@)(@(@)(x)) form of Associative Reference makes it easy to separate the @(@)() from other indexed values ()() or (Slots).

<Small>
A short form @u@host.tld can be found as well, it is always contiguous but breaks quoted whitespace and control characters. Wrap it with (). 

Always use the correct form.

In STFU in Text (or JSON, etc) the Index Turns are the 63i "6-bit" "ascii numbers" each character or "Quoted Turns including UTF", spaces and whitespace are not inside the () unless quoted. The Numbers are 0..9a..zA..Z_- so you can cheat with "ascii" symbols and punycode can be included in @(@xn-stfu.tld) without encoding. The only quote mark is "double-quote" %2  (NEVER "UTF16" except in js quotes.)

Use UTF8 "text" unless it's in a JSON string as \uxxxx.

Use STFU's reader.

</Small>

In STFU7 & STFU8, STFUf, or the binary STFU*, Contexts are more exactly referenced.


<h3>@(@)() in Text Examples</h3>

The @(@) Context Reference in ANY Text is a combination of the Context Tree and the supporting "named" Host Context.

@(@) in text is a "UTF" string or 6-bit number as "ascii" (or null) indicating the primary context,

Context:
@(ğŸ©
then the optional context's tree with '
@(ğŸ©'ğŸ˜'345'A'ğŸ¦“
The @ Context delimiter
@(ğŸ©'ğŸ˜'345'A'ğŸ¦“@
and the Host Context
@(ğŸ©'ğŸ˜'345'A'ğŸ¦“@stfu.site
that can also have an "IRI" (URI, URL) styled path
@(ğŸ©'ğŸ˜'345'A'ğŸ¦“@stfu.site/demo.php/
or fully formed "IRI" in "UTF"
@(ğŸ©'ğŸ˜'345'A'ğŸ¦“@https://stfu.site/demo.php?x=
Closed with the ) other containing control symbol
@(ğŸ©'ğŸ˜'345'A'ğŸ¦“@stfu.site)

The "named" Host Context assumes TLD, but can be any system type.
~(demo'tel'sms)(1'000'000'0000)






<h2>STFUjs</h2>
 
STFU's reference Implementation STFUjs @(STFUjs@stfujs.com) handles all of the forms of STFU's Accurate Representation using bits and performs the presentation of your Concepts!

Not only can it accurately represent a reference or some concept, STFU also makes sure all of your concepts are presented exactly the way you want them to be!

See the tutorial or reference implementation.




<h1>STFU7 + "STFU8", STFUf, & STFU*</h1>
STFU: Standard Text Format - Universal provides an effective Standard encoding.

The old "UTF8" described a simple method of providing a symbol that is easy to find that aligns the patterns of bits accurately.

STFU uses this pattern and technique to include all of UTF in STFU and also provides other techniques like the scoped and arbitrary length STFU*.

The leading bits signal that if it is an Expander

1 it's an Expander
11 it's an alignment & count symbol
10 it's a continuation of included bits

0 is a Control Symbol or a Collection of Bits  (Number)
01 Control Symbol
00 Collection of Bits

This set, Whatevers ã€°ï¸ := 
{Packed Bits, Control Symbols, Expanders}

<H2>Elementary Expanders: ğŸ¤ª</H2>

The Expander uses the leading high "msb" bit and then either a count sequence or the low bit to start included bits, as described by "UTF8".

STFU uses Expanders of any bit length ("8" in "STFU8" (STFU7), "16" in STFUf, and arbitrary in STFU*.

STFU uses the full range of included bits, 8 Byte chains in STFU8, 16 in STFUf, or the arbitrary sized STFU*.

These include the entire "UTF" "code point" set in values less than 2^2x. (BOM can be included in STFU "text", but certainly not required, and never in STFUf nor STFU* except in "text" in STFU Expanders.)

<H2>STFU's Control Symbols:</H2>
Leading Bits 01 is the STFU Control Symbol.

Like the Expanders, STFU's Control Symbols are arbitrary in scope >= "4 bits" (3i) and optimized for "STFU8" (STFU7) and the formalized Universal STFUf. ("STFU16")

<H3>01{0,1} Connected Control Symbol ğŸ¤¯</H3>

011 The next in sequence is part of this Control
010 The next in sequence is NOT part of a Control, it's data!

<H3>01x{0,1} Wrap ON|OFF Condition ğŸ’¡{ğŸŒ‘,ğŸŒ•}</H3>
01x1 Wrapper ON ğŸŒ•
01x0 Wrapper OFF ğŸŒ‘

These have all the information necessary to accurately represent all forms of knowledge and structure.

The most simple form is 0101(ğŸ¤ª)0100 indicating Wrapper ONğŸŒ•, Wrapper OFFğŸŒ‘.

010ğŸŒ• Whatevers ã€°ï¸{Expander, Control Symbol, Packed Bits} 010ğŸŒ‘

The same for Connected Control Symbols:
01ğŸ¤¯1(ã€°ï¸)0100 in a Declared structure

01ğŸ¤¯ğŸŒ•(ã€°ï¸)01ğŸ¤¯ğŸŒ‘ where the ğŸŒ‘ OFF Control Symbol may also have stuff inside.

ONğŸŒ• and ğŸŒ‘OFF sequences ALWAYS have matching Symbol type, off can have more stuff in the Connected Control System too! ğŸ¤¯

The next 3i "4 bits" of STFU8 have Logical Direction and types too!

<!--
<H3>"STFU4": STFU3i Control Symbols</H3>

Starting with STFU4's "2 bit" Control Symbols,

STFU3i has the minimal controls for wrappers in 4 bits total but is horribly inefficient for more than a few bits.
-->

<H3>Logical Direction â†•ï¸</H3>
Leading bit 01xx{0,1} is the Logical Direction

The "5th bit" adds the Logical Direction!

This is applied to all the symbol types.

<H3>STFU8 Control Symbol Types</H3>
Based on the Logical Direction, the next 3 bits in sequence tell the type of the Control Symbol.

The Control System types are internal the Declaration structure when leading bits are 011ğŸ’¡ ( a Connected Control Symbol ). 
01ğŸ¤¯ğŸŒ•â†•ï¸xxxã€°ï¸ã€°ï¸ã€°ï¸01ğŸ¤¯ğŸŒ‘â†•ï¸xxx

The Control System types are part of the information's Wrapper with ONğŸŒ•|OFFğŸŒ‘ when 
010ğŸŒ•â†•ï¸xxx ã€°ï¸ã€°ï¸ã€°ï¸ 010ğŸŒ‘â†•ï¸xxx
<b>and are of the matching Control Symbol type!</b>

Some specifics of the value.

Because the included information is prefixed by its Logical Direction, it is either {less or more} or {inside or outside} or {Parts or Wholes}

The data is always a Whatever:ã€°ï¸{Packed Bits, or a STFU Expander ğŸ¤ª, or another Control Symbol}, formal.

Bits: {0,1} from Logical Direction indicator is {less,more}:

01ğŸ¤¯ğŸ’¡â†•ï¸xxx

ğŸŒ‘xx: is Whatevers ã€°ï¸{Packed Bits,Control Symbol,Expanders}

000: {Single Whatevers ã€°ï¸{Bits,Control Symbol,Expanders}, } 

: {Count of Bits, Iterator Multiples} structures

: {Depth, Turn of Index}
: {Count, Slots of Information}

: {Parts, Wholes} of Bits such as fractional 1/(2^n) or 2^n
: {Differencing, binary 2^} of Bits

ğŸŒ•xx: Declarations and Composits

111: Declaration: {definition is inside, Reference a Declaration}



<H3>Connected Control Symbols</H3>

The sequence of controls, when connected, provides definitions of any diversity of structure.

Each structure Declaration can have Index Turns or Slot Values and any combination of Control Symbol types.

There are many ways to use STFU's Connected Control Symbols for more effective.

Seek hints are the most common, such as size of data in the Wrap ( inside 011 to the next 010 ) or offsets in whatever direction or additional structure Declarations. Depth Levels and Slot counts are also common.

01ğŸ¤¯ğŸŒ•â†•ï¸xxx(ã€°ï¸ã€°ï¸ã€°ï¸)01ğŸ¤¯ğŸŒ‘â†•ï¸xxx

01ğŸ¤¯ğŸŒ•â†•ï¸xxx(ã€°ï¸ã€°ï¸ã€°ï¸)01ğŸ¤¯ğŸŒ‘â†•ï¸xxx 01ğŸ¤¯ğŸŒ•â†•ï¸xxx(ã€°ï¸ã€°ï¸ã€°ï¸)01ğŸ¤¯ğŸŒ‘â†•ï¸xxx

<H3>ğŸŒ‘ğŸŒ•</H3>
//ğŸ¤¯ã€°ï¸\ğŸ¤¯/ã€°ï¸ã€°ï¸ã€°ï¸\\

<H2>Collections of Bits:</H2>

Inside leading bits 00, a Collection of Bits.

Like the Expander or Control Symbol, these are chained and each Bits is part of the sequence.

The values of each bits in STFU8 is 0 to 63i. 5i "6 bits" each.

Based on the Control Symbol Type, these Bits can be Wholes or Parts (integer, fraction), have a leading or scoped Container alignment, or be a Differencing (equal Halfs) or binary 2^n Accumulation.

<H2>Counting Numbers</H2>

All numbers are inclusive like the included collections of bits  [0i..5i] in STFU7 "STFU8" or [0i..13i] in STFUf
such as for(i=0;i<=5;i++) or while(i>=0){i--}

Leading (first) bit is most significant.

Counts are 0i Inclusive [0 to 0i] iterator.

<script type="text/javascript">

var x = new Array();
x[0] = new Array();//0..9a..zA..Z_-
x[1] = new Array();//#
x[2] = new Array();//[#ascii]
x[3] = new Array();//#
x[4] = [
[[48,10,0],[97,26,10],[65,26,36],[95,1,62],[45,1,63]],
[

// These are explicitly mapped, not | 2x01
33,35,36,38,39,40,41,42,43,44,46,47,59,61,63,64,126,10,
33,39,40,41,42,46,126,10
]
];

for(n=0;n<x[4][0].length;n++)
{
	for(v=0;v<x[4][0][n][1];v++)
	{
		PutNumbs(v+x[4][0][n][2],v+x[4][0][n][0]);
	}
}

for(n=0;n<x[4][1].length;n++)
{
	PutNumbs((x[4][1][n] | parseInt("01000000", 2)),x[4][1][n]);
}

function PutNumbs(a,b){
	x[0][a]=String.fromCharCode(b);
	x[1][a]=b;
	x[2][String.fromCharCode(b)]=a;
	x[3][b]=a;
}

function NSix(n,count,offset){
	var s ="";
	for (var i=offset;i<=count;i++)
		//s=x[0][(n>>(6*i))&0x3f] + s;
		s=x[0][(n & (0x3f << (i*6)))>>(i*6)] + s;
	return s;
}

function SixN(s,count,offset){
	var t=0;
	for (var i=offset;i<=count;i++)
		t= t | (x[3][s.charCodeAt(count-i)]<<(6*i) );
	return t;
}

function SixT(s){
	return ( Math.pow(2,10) * SixN(s,5,0) );
}

function TSix(t){
	return NSix(t/Math.pow(2,10),5,0);
}

function TSixNow()
{
document.write(TSix(new Date().getTime()));
}

//document.write("<hr> "+TSix(new Date().getTime()) +"<hr>");
//document.write("<hr> "+SixT(TSix(new Date().getTime())) +"<hr>");


function SpewChars()
{
for(o=0;o<x.length-1;o++)
{
document.write("<br>x["+o+"] = [");
for(q=0;q<x[o].length;q++)
{
if(x[o][q])
document.write(x[o][q]);
if(q!=x[o].length-1)document.write(",");
}
document.write("];");
}
}




//expand these to 8, option of next Expander (to 63i)

//into byte[].

 function char2utf8(input) {
    var output = "";

    for (var n = 0; n < input.length; n++) {
        var c = input.charCodeAt(n);

        if (c < 128) {
output += String.fromCharCode( (c>>6) | parseInt("11000000", 2));
output += String.fromCharCode( (c & 63) | parseInt("10000000", 2));
//String.fromCharCode(c);

//these are the same, crop 127, use sequential 8 = 42b

        } else if ((c > 127) && (c < 2048)) {
            output += String.fromCharCode((c >> 6) | 192);
            output += String.fromCharCode((c & 63) | 128);
        } else {
            output += String.fromCharCode((c >> 12) | 224);
            output += String.fromCharCode(((c >> 6) & 63) | 128);
            output += String.fromCharCode((c & 63) | 128);
        }
//through all 8
    }
    return output;
}

  function utf82char(input) {
    var output = "", i = 0, c = c1 = c2 = 0;

    while (i < input.length) {
        c = input.charCodeAt(i);

        if (c < 128) {
//stick control symbols here
            output += String.fromCharCode(c);
            i++;

        } else if ((c > 191) && (c < 224)) {
            c2 = input.charCodeAt(i + 1);
            output += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
            i += 2;
        } else {
            c2 = input.charCodeAt(i + 1);
            c3 = input.charCodeAt(i + 2);
            output += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            i += 3;
//and the full length
        }
    }

    return output;
}

function checkSTFU8(s,radix,decorate)
{
var ss = "";

for (var n = 0; n < s.length; n++) 
        ss += " " + s.charCodeAt(n).toString(radix);
//s.charCodeAt(n);

return ss;
}

function char2bits(s){
return " STFU8: " + checkSTFU8(char2utf8(s), 2, 0);
}

function FormatSTFU8(){} //put this Back into STFU8 Standard Declarations

</script>


<H2>All Characters are in Expanders.</H2>

ALL "letters" or symbols "character" are encoded in STFU.

(These include the old "ascii" <= 127. All of them are encoded in Expanders. 
Control Symbols are NOT "text" in 01x*
Collections of bits are packed in 00x*)

110xxxxx 10xxxxxx in STFU8

110xxxxx xxxxxxxx  10xxxxxx xxxxxxxx in STFUf

For example: <script>var s = 'a';document.write(s + " or " +  s.charCodeAt(0).toString(2) + " is:" + char2bits(s));</script>

Or letter '0' should actually be zero?
<script>var s = '0';document.write(s + " or " +  s.charCodeAt(0).toString(2) + " is:" + char2bits(s));</script>

Otherwise these aren't  
<script>var s = "'Numbers'";document.write(s + " :" + char2bits(s));</script>

<H2>STFU in TEXT to STFU Accurately:</H2>
The simple STFU @(@) Context in text can be converted to Standard STFU easily!

Bits in text are represented as 63i Symbols (from "ascii"). In STFU, bits are packed as bits.

0123456789
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZ
_-

The "64" Numbers and Control Symbols are mapped from "ascii" of the corresponding "character".

Control Symbols in the text, namely @(') !(') and some others *() ~() .() are converted to the more effective STFU when validated. !'()*.~ 

Everything else, both "UTF" and "ascii", are packed in STFU Expanders.

<H3>...</H3>
<H3>Fluffy Expander:</H3>
This "Fluffy" Expander example handles packing and unpacking of the STFU* variable length encoding.

See the STFUjs on how to form or read @(@) Contexts in texts accurately.





<H2>...</H2>









<H1>outdated text</H1>
---
<H3>Expanders & UTF8</H3>

All 8-bit Byte Expanders are available:

len byte[0]  byte[1]  byte[2]  byte[3] ...

"UTF8":

2 [10i]    110xxxxx 10xxxxxx
3 [15i]    1110xxxx 10xxxxxx 10xxxxxx
4 [20i]    11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

<B>The "Books" above 2^23i include the "UTF" in slot 0
and the forms, layout, tooling, phonemes,
and properly sorted "Code Points"; 11111000 is "UTF"</b>

5 [25i] 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
6 [30i] 1111110x + 5Ã— 10xxxxxx
7 [35i] 11111110 + 6Ã— 10xxxxxx
8 [41i] 11111111 + 7Ã— 10xxxxxx + Another Expander

---
<H1>Symbol Tables</H1>

For any Symbol Table: A Control Symbol or Chracter $

$(index)

$(number'{utf8|$()|Number}'index'tree)(v)

or

$({Any Expanders})

$({Any Expanders}'iNd3X'{Any Expanders}'TreE)

But not mixed in any Turn.

<H2>Turns & Slots</H2>

The entire system is based on a Control Symbol (sometimes with a initial time slice), a sequence of Turns through a route "tree", a matching composite value, and compositions of sets in Slots. 


$(turn'turn)({any})
With time: $<script>TSixNow();</script>(turn'turn)({any})

In any of these, both the Turns and Slots, a STFU8 or UTF8 "text", a Context @(@) or !() or a Reference with Associative, an indexed tree ()() and composition, a *() "type" Declaration or a System ~(bits) can be included. A Number can be used as a Turn, as can a STFU8 or UTF8, even a turned reference Context!

Or a set (') of any of them in Slots with or without the Turn index named. [N] if not ()()


<H2>Adding Time:</H2>

The initial time slice can be included for temporal versioning,
it's associated references per referenced initial time as well.

Numbers are 6-bit, the initial time slice is msb aligned to resolution.

$() and $()()
<!--
Plus 4Ã—6=24 bit time:

$<script>TFourNow();</script>() and $<script>TFourNow();</script>()()
-->

Plus 6Ã—6 bit Time:

$<script>TSixNow();</script>() and $<script>TSixNow();</script>()()

The time comes from a chopped 64b time, called "Fone"

The Fone's time is chopped to 2^10 ms, slightly more than one clock second, 65 Fone Seconds, and 6 bit multiples. A short Fone slice is Fone Minutes or Fone Hours, to 64Ã— each.




---
<H1>HTTP Bytes</H1>

There is a compatibility mode for HTTP
using the old "ascii" characters as control symbols and numbers:

<script>
for (
var i = 0;
i <= 255;
i = i + 1
)
{
var s = String.fromCharCode(i);
if (
s == encodeURI(s)
&&
s == encodeURIComponent(s)
)
document.write(s);
}
</script>

Out of:

<script>
for (
var i = 0;
i <= 255;
i = i + 1
)
{
var s = String.fromCharCode(i);
if (
s == encodeURI(s)
)
document.write(s);
}
</script>

Thereby:

$(Index'Tr3E)(v)

---

For @ and !, the Universal Contexts:

@<script>TSixNow();</script>(Context'tree@host.tld)(ğŸ˜´) is an Associative Reference 
@<script>TSixNow();</script>(Context'tree@host.tld) is the Context (and "file" name!)
@<script>TSixNow();</script>(Context'tree@host.tld)() is the References "file"!

Same for !() and !()()

Or without time:

@(Context'tree@host.tld)
@(Context'tree@host.tld)()

These are the URI IRI URL "file name" or reference. at host.tld's interface, as declared in "/@(@host.tld)" or "/@()" "file" via host.tld

<!--
\n
(
~
(index'Tree)(v)
)
\n

!'()*-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~

Out of:

 !#$&'()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~ 

-->

---

<H1>Transport Syntax</H1>

HTTP and IRI (URI, URL) "% encode" everything except:

POST:

!'()*-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~

GET & HEAD:

 !#$&'()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~ 

Of the available "ascii characters", 

<H2>63i Numbers:</H2>

0123456789
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZ_-

<H2>Control Symbols:</H2>

Per the available Symbols from HTTP the Syntax is $(')()

# breaks in "IRI"
$ breaks in PHP, etc
? & = ; break POST & GET
* and : break in file systems
/ is IRI Path
punycode has mutilated -
and social media misuses _


POST:

!'()*.~

GET:

 !#$&'()*+,-./:;=?@~

Available for HTTP Transport:

!'(),.;@~

And POST:

!'().~

The containing Symbols ( "leading hand" and ) "other hand"
combine with the ' as $((')(')'()())() 
to form (iNd3x'Turns) with (index)(Slots).

These Numbers, Control Symbols, or Expanders (including "UTF8")
provide the tree's Turns and the set's Slots.

<H2>Numbers & Control Symbols:</H2>
<small><script>SpewChars();</script></small>


---
<H1>Universal Structure:</H1>


<H2>Structure:</H2>

A local, universal, context, and system table are each required:

~ System
! Universal
.() Local
@ Context

The system table is explicitly reserved for host implementations but includes the minimal standards for operation.

The ! Universal Context is well-formed and extensible by any !() or the abbreviated @(@).

ALL character encodings including those < 128
use Expanders of 2 or more octets with high bit set.

The 64 numbers are 00xxxxxx and mapped to ascii in the initial encodings.

The @(@) Context is a combination of the context tree and the supporting "named" host.

@(@) are typically a "UTF8" Expander or 6-bit number (or null) indicating the primary context,
@(ğŸ©
then the optional context's tree with '
@(ğŸ©'ğŸ˜'345'A'ğŸ¦“
The @ Context delimiter
@(ğŸ©'ğŸ˜'345'A'ğŸ¦“@
and the UTF8 Expander
@(ğŸ©'ğŸ˜'345'A'ğŸ¦“@stfu.site
that can also have an "IRI" (URI, URL) styled path
@(ğŸ©'ğŸ˜'345'A'ğŸ¦“@stfu.site/demo.php/
or fully formed "IRI" in "UTF8" 2+ Byte Expander
@(ğŸ©'ğŸ˜'345'A'ğŸ¦“@https://stfu.site/demo.pho?x=
Closed with the ) other containing control symbol
@(ğŸ©'ğŸ˜'345'A'ğŸ¦“@stfu.site)

Because ALL characters are "UTF8" Expanders, there are no " quotes or other convolutions.

The "named" host assumes TLD, but can be any system type. ~(demo'tel'sms)(1'000'000'0000)

<H2>Where you at?</H2>

For @ and !, the Universal Contexts:

@<script>TSixNow();</script>(Context'tree@host.tld)(ğŸ˜´) is an Associative Reference

@<script>TSixNow();</script>(Context'tree@host.tld) is the Context (and "file" name!)

@<script>TSixNow();</script>(Context'tree@host.tld)() is the References "file"!

Same for !() and !()()

Or without time:

@(Context'tree@host.tld)
@(Context'tree@host.tld)()

These are the URI IRI URL "file name" or reference. at host.tld's interface, as declared in "/@(@host.tld)" or "/@()' "file" via host.tld

<H2>Local Context:</H2>

Within a Context, indicated by the Tree of Turns,
there is content within:

@(ğŸ©'ğŸ˜'345'A'ğŸ¦“.(some'thing)@stfu.site)

The ' and . are handled the same as ~ and !
.(local'tree), though ' is exclusively Turns or Slots in sets. ( starts a turn or set of slots. Implied " (' ".

This Turn, .() indicates the next turns are inside the container or box.

!(~(wire)(~(bits)('''))'(in'set)'@(a@b)'ğŸ¤£.(3'ğŸ¤—))

Because @(@) is a courtesy wrapper for !()(),
Both @(@) Context and all of the structures anywhere have the Turn Tree and the value.

In .(local'data)(this pair is a value, here it's an Expander)

The ' of Turns also functions the same way, allowing an in'set turn.

In any level, the ()((local'data)(value))

Or as a set of Slots:

()((local'data)(value)'RAW '(STFU8'UTF8)' in 2 octets or 10xxxxxxs '(local'STFU8'data'4)(value)'etc8s)

The @(@) Context and !() are the same way:

@(@)((local'data)(value))

Or more importantly

@(demo's0me'TrEe@stfu.site)(@(jack@twitter.com)(ğŸ¤))

Associative Reference!

This can map an @(@) or !() with the Associative Reference, typically a formally structured Syntax or an Expander suitable for the concept of inter-contextual association.

Internally at any level, any element in the tree can be associated to anything else:

.(local'data)(@(demo@stfu.site)(ğŸ¤¬))

Or

@(demo@stfu.site)(@(demo's0me'TrEe@stfu.site)(ğŸ¤ª))

Or between specific data points inside the box:

@(ğŸ©'ğŸ˜'345'A'ğŸ¦“.(some'thing)@stfu.site)(@(demo's0me'TrEe.(local'data)@stfu.site)(ğŸ¤¯))

Simple!

@(demo's0me'TrEe.(local'data)@stfu.site)(@(ğŸ©'ğŸ˜'345'A'ğŸ¦“.(some'thing)@stfu.site)(ğŸ˜œ))


---
<H1>Associative Reference</H1>

Like the pair of @(@)(ğŸ¤—) associations, any point in any context can have inter-related associations with any other, anywhere.

In !()() this is called "Cube" and "Ball" held leading-hand and other-hand.

The "cube" has a box that holds stuff.

The "ball" is the Universal Context.

Your stuff is in the box, including your concepts of how other stuff is related (or not) anywhere, in the box or far beyond!

Your "cube" has its own "ball" where references from anywhere else are posted for reference. Every "cube" Context does!

Any Associative Reference can have a diversity of attributes. This includes the standard set and any others that you can come up with, including association by another concept in any context.

<H2>Associative Syntax Structure</H2>


---

<H1>Additional Standard Control Symbols:</H1>

@ Context @(@)
! Universal !()()
~ System Tables ~(bits)
.()() And ()() Local data

<H2>Declaration "type" Anywhere!</H2>

*() Declaration "type" anywhere

Any (named'index'ğŸ¦“)(@(ğŸ©'1am'ğŸ˜´@stfu.site)(ğŸ˜œğŸ¤¯ğŸ¤ª)) can include an Associative Reference with it's own type!

.(named'index'ğŸ¦“)(@(ğŸ©'1am'ğŸ˜´@stfu.site)(*(@(ğŸ˜‹'types'associative'ğŸ˜@stfu.site)'
(ğŸ˜'value)(3)'(ğŸ˜'type)(ğŸ¤¯)
))


Is an easy example of a Declared *() "type" using named index values for Accurate Representation!

Any structure of knowledge or concepts can be represented and presented this way using the Declaration's referenced "show" "cube" "ball" "flow" and related definitions.

<H2>,() "Alternate Text" ~(hint)</H2>

At any level of Slots (except Turns), 
" ,() " can be included as an alternate "hint" (typically a short text name or description), and "overload" values set in YOUR reference to another context, such as changing the color of a tooling in the "cube" when using their layout process.

<H2>IRI Reference from ~(bits)</H2>

/() is included for IRI URI URL reference from a definition in the #Declaration *() on how to use those ~(bits). Typically the description exhaustively describes the structure (image).

---
<H1>Declaration Conditions</H1>

The entire system uses one standard format and one *() Declaration that includes the "host" Implementation getting and setting bits. 

Containers of bits referenced in the host have their Declared structure and describe their processes or configuration therein.

Valid "host" Implementations might extend a more direct physical process, like an ADD function of a Declared fixed bit width or "glsl" triangles into "show" or "flow". (Pixels)

<H2>Merging Structures</H2>

Multiples shall be handled as parallel records such as [a,b] of the same but different; many Associative References exist between the same Concepts, and similar Contexts may merge in presentation!

---

<H1>Declaration + "type"</H1>

The Control Symbol *() is the Declaration.

The Declaration either contains the definition of the structure or contains a reference to a Context that Declares the type's structure.

The Declaration *() can contain the entire definition and how to correctly present your concepts or context anywhere!

All structure, and all operation (such as the representation of your "cube" and "ball" and how to "show" them) are defined in the Declaration *()

The host Implementation need only a minimally simple and formally valid ability to copy bits to various "wire" or "line" interfaces including screen pixels, phone or Internet connectivity, or the host's memory.

The system in whole uses a "Table Basher" that is formally valid everywhere and collections of ~(bits) and *(structures) that you define.

There is a minimal or host implementation augmented set of "Truth Tables". ~(true) And logic "flow".

The *() includes everything necessary to calculate the Accurate Representation of your Context, Concepts, and Associated References and "show" them any way you want!

There is a Declaration of how to "show" your Context, including how to Accurately Represent your "cube" and "ball", and inter-associated concepts beyond your "ball" in the "show"!

Every Context has a cube and a ball, at every level.

The cube has stuff in a box, the ball has the Universe.

The cube has its own ball! Infinitely many cubes and balls inside each little Context (but preferably each general concept in it's own context) STFU!

The type Declaration * takes care of everything else!

<H2>Truth, Logic, FLOW</H2>

The elementary logic, presentation, data representation, ... and flow control are all contained in the System Table.

All you really need is the ability to copy bits between some place to another, at any scale.

By using bits and containers of bits with only a minimal get&set function, every Context controls the entire process of Accurately representing it's data and presentation!

<H2>SHOW CUBE BALL</H2>

Every context, at any level, is provided a "cube" to Accurately represent it's stuff.

Within the 4D cube, a 3D volume and time, you can represent your STFU any way you could possibly want!

Animation, 3d objects and tooling, human interaction, layout graphemes or audible phonemes, etc. You have explicit control of how your context is represented!

The "show" and it's "flow" in the *() Declaration describes how your concepts are presented in your "cube", how data from your STFU boxes are represented, and how Associative References in your cube or from it's ball are presented.

Beyond your "cube" at any level is a "ball" that includes the Contexts and Associative References for the entire universe.

Your *() Declaration's "show" handles ALL of the layout and presentation for your Concepts and Contexts anywhere they go, and do exactly the same for every STFU Context that gets to you!

<H2>Declaration Efficiency, Burdon</H2>

The Declaration *() includes an overview of the technical processes of presentation including controls for efficiency, complexity, detail, and the description of how to Accurately Represent the Concepts in the best way for anyone.

Everything goes in a "cube" or controlled by a "ball"!


<H2>Declaration's in Contexts</H2>

Every Context has a Declaration of it's structure and how to Accurately present it.

Any specific data can include it's own unique "show" or "type" or it can reference a Context *(*(@(@))) somewhere that describes a way you prefer.

Multiple ways are merged for the most correct representation possible!


<H2>FLOW & control</H2>

Every process related to your Context is controlled entirely by your description in the *() Declaration.

The entire system does nothing other than move bits around and tell the host Implementation to put bits as pixels on a screen or put bits to wire and get some more! (Any wire, audio, video, interfaces, camera, phone or Internet, or as a host for the data!)

Extensions of the bit operations in formally valid implementations make Accurate Representation and presentation very fast and efficient!

Entire complexities of process can be implemented in your Context with the "show" "cube" "ball" "flow" in the *() Declaration.

The template that shows this structure and Accurately Represents these Concepts is simply a set of descriptions in the Declaration that request the valid implementations "host" to move bits around to various places ALSO described by a Declaration in a Context.

Anywhere!


---

<H1>Initial Time + Re-Visioning</H1>

Accuracy of Representation is important. When you reference something you expect it to be accurate, not randomly changed into something else.

Control codes for previous & next allow the sequence in time to be loaded together.

A context could change to someone else, or become outdated.

@<script>TSixNow();</script>(@) or @<script>TSixNow();</script>(@)
!<script>TSixNow();</script>(...)

allows for a nÃ—6 bit initial time slice to be indicated, providing versioning and history and the References to it can be stored on the local time slice as well. msb aligned

@<script>TSixNow();</script>(@)() ALL THE REFERENCES!

It's better to create a new timeslice or tree'd Context when things change, keeping the other ones because someone somewhere else might reference them!





---

<H1>Tools of Implementation</H1>

In order for your Concepts and References to be Accurately Represented, you need to use 


This can be loaded and referenced accurately in parallel starting at any point using an expanding tree or linked-list that has offsets.

Because the Control Symbols and Numbers are never STFU8 "text" nor UTF8, they will always be accurate.

A \n newline is processed similar to the ' but only between 

The Context "file" @(@) has everything in this simple box.

Your Accurate Representation is shown in a "cube" with all your local references and any local references to anything else!

The Associated References "Ball" @(@)() "file" has ALL of the references to it from anywhere else and is open-ended so it can be appended.

Same for !() and !()() 

---

<H1>Formal Syntax</H1>

Bit-Sequential processing tree with parallel offsets and optional alignments

.()(@(.()@)) expands inline.
()()' vs .()() locals

---

<H1></H1>

---

<H1></H1>

---

<H1></H1>

---


<H1></H1>

---


