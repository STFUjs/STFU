

STFU(0)





<hr>


<hr>
<pre>
<font size="8in">
STFU: STANDARD TEXT FORMAT - UNIVERSAL
</font>

<H1>STFU: STFU* + STFUjs, STFU(7): "STFU8", STFU(f), & STFUx</H1>

<h1>STFU: Standard Text Format - Universal</h1>

STFU has a variety of matching formats that Accurately Represent all forms of communication and Conceptual Representation using bits and provides instructions for the elementary processing of bits for Accurate Representation of Concepts.

STFU includes the entire capacity to Declare and Accurately Represent all possible Concepts and information in Standard Contexts that include presenting any diversity of Representations and perform any capability using bits.

STFU is a standard "text" form that uses @(@) & !()() Universal Context References in UTF8/"ascii", and is an arbitrary bit scope STFU* including STFU(7) "STFU8" and STFU(f), and a standard formal Collections of Bits. Etc.

<h2>STFU in Text</h2>
STFU is an effective and efficient standard for Referencing any STFU Universal Context,

@(you@your.site.tld)

And any Associative Reference

@(me@mysite.tld)(@(you@your.site.tld)(how))

Within or between any Context.

STFU provides an Accurate Means of Representation, direct control of ~(bits), and a Declaration of Structure with *(@(@)) inside!

<h2>STFU*, STFU(7) & STFU(f), STFUx(*)</h2>
STFU is an <b>effective</b> and efficient standard for the comprehensive Accurate Representation of Inter-Associated Concepts and Universal Context References.

The Packed <b>Standard Text Format - Universal</b> standard includes arbitrary and fixed-scope binary encodings that contain all parts of the STFU Standard accurately.

STFU contains 3 primary parts: Control Symbol Wrappers, Collections of Bits, and STFU Expanders that include the entire Unicode plus the STFU Books of Symbols.

Leading Bits:

00 Control Symbol Wrap
01 Packed Collections of Bits
10 Expander 
11 Expander Alignment

Regardless of scope or host implementation block size, STFU is an effective and efficient standard for packaging all data in simple fast bit fields of any scope.

Wide parallel test of 
11... 11... 
across any size bit field indicates 

0: Control Symbols present,
1: Packed Bits or Expanders present,

then a preferential method to isolate each Symbol.

00... STFU Wraps & Connected Wraps
01... Packed Bits
10... Expander Bits
11... Expander Count + Bits

The STFU Connected Wraps can include seek and size data along with the standard STFU Wrappers, allowing very fast extraction and construction of accessors.

STFU Wraps, Connected Control Symbols, Bits, and Expanders are packed in 

STFU8 ❌✖️ + 6-bit collection
STFUf ❌✖️ + 14-bit collection
STFU* ❌✖️ + any block size - 2b

The Expander Alignment uses a count high bits then a low bit.

<h3>STFU Control Symbol Wraps</h3>

The STFU Wraps are "Connected" or singular Wrappers for any of the types of information.

When Connected, STFU Wrappers contain structured information about the Packing technique and wrapped data.

Wrappers can contain any of the Expander, Packed Bits, or more STFU Symbol Wraps. (Only STFUx of any scope allows raw bits.)

The Control Wraps include the elemental requirements for Accurate Representation, including Universal Context References, Means of Representation & Declaration of Structure, Logical Direction and Turns & Slots, and technical specifics.

<h3>Packed Collections of Bits</h3>
Bits are contained in Packs, combined by spreading them across the scoped containers.

Collections of Bits can be structured, as described by the Declaration you include or by reference in each STFU.

The STFU Control Symbol indicates if they are Parts 1/(2^n) or Wholes (2^n), their alignment inside, and possibly their size.

<h3>Expanders</h3>

Expanders start with the leading bit 1 and are either the Expander Alignment Symbol 11...0... or the Expander Bits 10...

Similar to the old "UTF8", the Expander starts with an indication of how many blocks are included in the Expander Sequence.

The Expander can use any size container of bits, the pattern is the same.

All "characters" including Unicode "UTF" < 2^21, and the BOOKs of STFU Symbols above 2^21 pack in Expanders. 

STFU BOOKs formalize symbols in books of symbol pages of 2^24 each. Intermediate transitional collections ("code points", etc.) are in STFU books between 2^21 (UTF) and 2^24.

Because of STFU*'s arbitrary bit scope, index "characters" go in as many containers as they need and are not larger than scope*(scope-2) bits. There's STFU's Packed Bits ;)

Starting with 
10... One Container
110... 2 Containers to
11...10... A total count of Containers + 10...'s for Each Container
Of the Container's bit scope's count (full 11...11)
As needed to hold the index value.

Using the prefixed count 11...10... vs 10... makes finding the Alignment Symbol faster in the Expander Sequence and extracting the index value accurately by bit field spreads or masked bit shifts.

From an Expander Alignment Symbol, counts are sequential, a 10... that's not within the count is another, the sequence truncated by a Packed Bits Container or Wrap Control Symbol. xx

All "characters" are in Expanders.

In STFU8 an "ascii" <= 127 is packed in 2×8-bit: 110.....10...... to not break the old "UTF8".

<h2>STFU BITS</h2>
The standard form BITS is the optimal structure for containing formed collections of bits regardless of bin size or structure complexity.

Leading bit 0 indicates a 2-bit Differencing
Leading bit 1 indicates Binary Bits in Blocks

The initiator is a pulse driver select for either

0: 2-bit Differencing Symbols with STFU types or
1: Pulse Driver for initial Block size in Binary bits.

The structure of bits in STFU BITS has STFU types.

The Binary structure and Differencer can inter-mix and can represent all composites of bit structures including each-other.

If the initiator (leading msb bit) is high,
(signaling initial Blocks of Bits)
Increment low until next high pulse.

10000001 signifies "8-bit" symbol, 0 to 7 iterations Inclusive.

The minimum is 11, a 2-bit initiator that provides the structure of BITS in an 8-bit structure.:

count of Bits in container Block
count of Multiples of Blocks
count of Multiples of Multiples
a Composit of structures
an extension of Multiples (Dimensions)

A STFU Declaration and associated BITS is preferred over STFUx.

<h1>STFU & STFUjs</h1>
<h2>STFU <b>Standard Text Format - Universal</b></h2>
STFU Accurately represents ALL knowledge and conceptualization in a simple and <b>Standard Text Format - Universal</b>.

In any natural language or technical representation, concepts are related to concepts by other concepts...

In any form, the structure of communication is an attempt to convey concepts.

Most natural languages, be them spoken or written or graphical or gesture, lack sufficient effective structure and are inefficient. Technical representations are lacking.

STFU combines all these requirements for Accurate Representation into one <b>effective</b> form!

STFU's STFU7 + "STFU8", STFUf, & STFU* (and STFUx) are exhaustive formal standards.

<h2>STFU in ANY Text</h2>
Most communication uses some form of text or structure, STFU can be used anywhere!

<h3>@(@) Context</h3>
@() is the general form of a Context

@(@) is the Context accessable somewhere

@(My'Concept'TrE3@mysite.tld)

Every @(@) Context is inside the the Universal Tree. In the more sophisticated !()(), the structure is more explicit.

<h3>STFU's General Form: @(@) Context</h3>

STFU uses one standard form, an indicator Symbol with a Set of Turns ("path") and a Set of Slots (information).

@(@)()

The first expansion includes the full Context:

@(intro@stfu.site)

This is the parts "Entity Context" [at] "Host Context" 

The Host Context has its own STFU Context @(@host.tld) that's inside the Universal Context.

@(@me.site.tld) is the preferred Entity Context

The Host Context can be implicit @(this'part) inside some "text", but the fully formed @(demo'this'part@stfu.site) is preferred.

A Context exists at any level of the Universe.

An "Entity Context" can be included, such as your @(name@my.tld)

Any Context has any diversity of sub contexts, so you can use @(me'stuff@my.tld) in the Universal Tree of Turns.

The Context can 
@(pet'toys'3@my.tld) have named or numeric indexes in the Turns, and references to other contexts.

Each Context can have lots of stuff inside, and you Declare how it is presented!

Inside any Context,

(Turns'in'Trees'4'5)((Slots'Slots)'oR'(3'2'more'1'turns)(aAzZ-_-_)'(indexed)(Slots))

Symbol ' is used similar to [,] or {,} in either Turns or ()() named/indexed or () unnamed Slots.

() and ()() both use the same characters because it gets through HTTP correctly. (See below.)

The Universal Context !()() is formally structured and includes all of @(@).

<h3>@(@)() Associative Reference</h3>

Because every @(@) Context of STFU's Universal Context includes the Tree of Turns and the information in that Context, inter-relations of Concepts are extremely easy!

All Structures of Representation have their Tree of Turns and their information in Slots.

Concepts are represented by information in Slots.

A Slot can have an Associative Reference:

@(intro@stfu.site)(@(pet@stfu.site)(likes))

This Inter-Associative Reference is available anywhere, inside the same Context or between any Concepts anywhere!

@(me'stuff'pet'toys'"Green Thing"@my.tld)(@(pet'toys'3@my.tld))(same))

The Associative Reference can be a simple text or collection of bits or a Declaration.

@(@)(@(@)(*(demo'refs@stfu.site)'(how)(345))


<h2>@(@)(@(@)()) The Universe, Referenced</h2>
<h3>STFU in Texts</h3>
Anywhere a Concept may be presented, a STFU Context can Accurately Represent it and the Concept's Inter-Association to other Concepts.

@(intro'Concepts@stfu.site) is Referenced

@(intro'Concepts@stfu.site)(includes) is Referenced Accurately

<h3>Finding @(@) Contexts in Text</h3>
Finding @(@) Contexts is easy!

Because the pattern @( is rare, as is !() as is the @<script>TSixNow();</script>(turn'turn@your.tld)({any}) Context with time, finding @(@) Contexts is easy!

It is easiest to search for the @ character followed by a ( Context or a 6 number "ascii" Time and ( in the same pattern:

@(you@your.tld)
@(you'stuff'🧠@your.tld)

Or with a specific Time:

@t1m3rS(you'stuff'🧠@your.tld)

Or with information:

@(you@your.tld)((refs)(1)'(my'type)(s2)'*(@(demo'type@stfu.site)))

Or an Associative Reference:

@(you'stuff'🧠@your.tld)(@t1m3rS(you'stuff'🧠@your.tld)(includes))

Combined:
@<script>TSixNow();</script>(You'turn@your.tld)(@t1m3rS(you'stuff'🧠@your.tld)(saw))

The optional initial Time is very important!

The @(@)(@(@)(x)) form of Associative Reference makes it easy to separate the @(@)() from other indexed values ()() or (Slots).

<Small>
A short form @u@host.tld can be found as well, it is always contiguous but breaks quoted whitespace and control characters. Wrap it with @(@). 

Always use the correct form.

In STFU in Text (or JSON, etc) the Index Turns are the 63i "6-bit" "ascii numbers" each character or "Quoted Turns including UTF", spaces, apostrophe, and whitespace are not inside the () unless quoted. The Numbers are 0..9a..zA..Z_- so you can cheat with "ascii" symbols and punycode can be included in @(@xn-stfu.tld) without encoding. The only quote mark is "double-quote" %2  (NEVER "UTF16" except in js quotes.)
Use UTF8 "text" unless it's in a JSON string as \uxxxx.

Use STFU's formatter and STFU Standards.

</Small>

In STFU7 & STFU8, STFUf, and the binary STFU* + STFUx, Contexts are more exactly referenced. SEE STFU8.


<h3>@(@)() in Text Examples</h3>

The @(@) Context Reference in ANY Text is a combination of the Context Tree and the supporting "named" Host Context.

@(@) in text is a "UTF" string or 6-bit number as "ascii" (or null) indicating the primary context,

Context:
@(🐩
then the optional context's tree with '
@(🐩'😎'345'A'🦓
The @ Context delimiter
@(🐩'😎'345'A'🦓@
and the Host Context
@(🐩'😎'345'A'🦓@stfu.site
that can also have an "IRI" (URI, URL) styled path
@(🐩'😎'345'A'🦓@stfu.site/demo.php/
or fully formed "IRI" in "UTF"
@(🐩'😎'345'A'🦓@https://stfu.site/demo.php?x=
Closed with the ) other containing control symbol
@(🐩'😎'345'A'🦓@stfu.site)

The "named" Host Context assumes TLD, but can be any system type.
~(demo'tel'sms)(1'000'000'0000)


<h2>STFUjs</h2>
 
STFU's reference Implementation STFUjs @(STFUjs@stfujs.com) handles all of the forms of STFU's Accurate Representation using bits and performs the presentation of your Concepts!

Not only can it accurately represent a reference or some concept, STFU also makes sure all of your concepts are presented exactly the way you want them to be!

See the tutorial or reference implementation.

Use STFU's Standard Infrastructure.


<h1>STFU(7) + "STFU8", STFU(f), & STFU(*) + STFUx</h1>
STFU: Standard Text Format - Universal provides an effective Standard encoding.

The old "UTF8" described a simple method of providing a symbol that is easy to find that aligns the patterns of bits accurately.

STFU uses this pattern and technique to include all of UTF in STFU and also provides other techniques like the scoped and arbitrary length STFU*.

The leading bits signal that if it is an Expander

1 it's an Expander
11 it's an alignment & count symbol
10 it's a continuation of included bits

0 is a Control Symbol or a Collection of Bits  (Number)
00 Control Symbol
01 Collection of Bits

This set, Whatevers 〰️ := 
{Packed Bits, Control Symbols, Expanders}

<H2>Elementary Expanders: 🤪</H2>

The Expander uses the leading high "msb" bit and then either a count sequence or the low bit to start included bits, as described initially by "UTF8" but with the full scope utilized.

STFU uses Expanders of any bit length ("8" in "STFU8" (STFU7), "16" in STFUf, and arbitrary in STFU*.

STFU uses the full range of included bits, 8 Byte chains in STFU8, 16 in STFUf, or the arbitrary sized STFU*.

These include the entire "UTF" "code point" set in values less than 2^2x. (BOM can be included in STFU "text", but certainly not required, and never in STFUf nor STFU* except in "text" in STFU Expanders.)

<H2>STFU's Control Symbols:</H2>
Leading Bits 00 is the STFU Control Symbol.

00🤯💡↕️✖️❌✖️

Or a Wrap:
00🌑🌕🌑🌑🌑🌑 〰️ 00🌑🌑🌑🌑🌑🌑

Like the Expanders, STFU's Control Symbols are arbitrary in scope >= "4 bits" (3i) and optimized for "STFU8" STFU(7) and the formalized Universal STFU(f). ("STFU16")

<H3>00{0,1} Connected Control Symbol 🤯</H3>

001 The next in sequence is part of this Control
000 The next in sequence is NOT part of a Control, it's your STFU's Wrapped Information!

<H3>00x{0,1} Wrap ON|OFF Condition 💡{🌑,🌕}</H3>

00x1 Wrapper ON 🌕
00x0 Wrapper OFF 🌑

These have all the information necessary to accurately represent all forms of knowledge and structure.

The most simple form is 0001(〰️)0000 indicating Wrapper ON🌕, Wrapper OFF🌑.

000🌕 Whatevers 〰️{Expanders, Control Symbols, Packed Bits} 000🌑

The same for Connected Control Symbols:
00🤯1(〰️)00🤯0 in a Declared structure

The next symbol could be an unconnected wrapper with Whatevers inside!

00🤯🌕(〰️)00🤯🌑 where the 🌑 OFF Control Symbol may also have stuff inside.

ON🌕 and 🌑OFF sequences ALWAYS have matching Symbol type, off can have more stuff in the Connected Control System too! 🤯

The next 3i "4 bits" of "STFU8" have ↕️ Logical Direction and types too!

<!--
<H3>"STFU4": STFU3i Control Symbols</H3>

Starting with STFU4's "2 bit" Control Symbols,

STFU3i has the minimal controls for wrappers in 4 bits total but is horribly inefficient for more than a few bits.
-->

<H3>Logical Direction ↕️</H3>
Leading bit 00xx{0,1} is the Logical Direction

The "5th bit" adds the Logical Direction!

This is applied to all the symbol types.

<H3>STFU8 Control Symbol Types</H3>
Based on the Logical Direction, the next 3 bits in sequence tell the type of the Control Symbol.

The Control System types are internal the Declaration structure when leading bits are 001💡 ( a Connected Control Symbol ). 
00🤯🌕↕️❌✖️✖️〰️〰️〰️00🤯🌑↕️❌✖️✖️

The Control System types are part of the information's Wrapper with ON🌕|OFF🌑 when 
000🌕↕️❌✖️✖️ 〰️〰️〰️ 000🌑↕️❌✖️✖️
<b>and are of the matching Control Symbol type!</b>

Some specifics of the value.

Because the included information is prefixed by its Logical Direction, it is either {less or more} or {inside or outside} or {Parts or Wholes}

The data is always a Whatever:〰️{Packed Bits, or a STFU Expander 🤪, or another Control Symbol}, formal.

Most of the data in connected control symbols is for line control and signaling or efficiency of processing, content sequences in time, same or  prior and later versions, wire and line (communication) specifics, and other parts of the Declaration.

Bits: ↕️{0,1} from Logical Direction indicator is {less,more}:

00🤯💡↕️✖️❌✖️

🌑❌✖️: is Whatevers 〰️{Packed Bits,Control Symbol,Expanders}

🌑🌑✖️: Whatevers 〰️ + Bits & Iterator Multiples
🌑🌕✖️: Turns & Slots + Parts & Wholes

🌑🌑🌑: ↕️{ Whatevers 〰️{Bits,Control Symbols,Expanders}, Implementation }
🌑🌑🌕: ↕️{Turn of Index, Slots of Information} Any Whatevers 〰️
🌑🌕🌑: ↕️{Count of Single Bits, Iterator:Multiples} bits & bit structures Compositor
🌑🌕🌕: ↕️{Parts, Wholes} of Bits or 〰️ such as fractional 1/(2^n) or 2^n


🌕❌✖️: STFU Declarations and Composits
Includes the Wrap Symbol's Types in both Connected Control Symbols and actual data.

🌕❌✖️: {Local Reference Inside, Universal Context Reference or local @()}

The set of STFU's standards includes the
↕️{STFU Reference with STFU Associative} local and Universal

Using the Connected Wrap's Control Symbols, the local or referenced STFU Declaration or Means of Representation, etc.

<!--
STFU Declaration: {definition is inside, Reference another Declaration} ↕️{STFU Declaration}
STFU Representation "show" and logic "true"
STFU References + Associative

: {Differencing Halfs, binary 2^ Accumulation} of Bits are 01 without other 
-->

↕️{Local, Universal} Context:
🌕🌑✖️: 
🌕🌕✖️: 

🌕🌑🌑: STFU Reference + Associatives
🌕🌑🌕: STFU Declaration or Means of Representation (include select parts) {contained inside, include Universal STFU or local @()}
🌕🌕🌑: {Structured STFUx BITS, Raw STFUx BITS ***}
🌕🌕🌕: (Extensions in STFU)

The STFU's Accurate Representation Declaration is included as it is complete.

Formally Declared STFU Expanders (such as logic and control pages in STFU Books) can be the Symbol's Whatevers.

*** STFUx must be processed in a very different way.

<H3>Connected Control Symbols</H3>

The sequence of controls, when connected, provides definitions of any diversity of structure.

Each structure Declaration can have Index Turns or Slot Values and any combination of Control Symbol types.

There are many ways to use STFU's Connected Control Symbols for more effective.

Seek hints are the most common, such as size of data in the Wrap ( inside 011 to the next 010 ) or offsets in whatever direction or additional structure Declarations. Depth Levels and Slot counts are also common.

00🤯🌕↕️❌✖️✖️(〰️〰️〰️)00🤯🌑↕️❌✖️✖️

00🤯🌕↕️❌✖️✖️(〰️〰️〰️)00🌑🌑↕️❌✖️✖️

00🤯🌕↕️❌✖️✖️(〰️〰️〰️)00🌑🌑↕️❌✖️✖️

00🌑🌕↕️🌑🌑🌑(Actual Information! Use STFU8)00🌑🌑↕️🌑🌑🌑

STFUx allows Wraps with raw binary data but requires size and offset and requires a Wrap-sequential processing of offsets, explicitly not parallel.

<H3>🌑🌕</H3>
//🤯〰️\🤯/〰️〰️〰️\/〰️\\


<H2>Collections of Bits:</H2>

Inside leading bits 01, a Collection of Bits.

Like the Expander or Control Symbol, these are chained and each Bits is part of the sequence.

The values of each bits in STFU8 is 0 to 63i. 5i "6 bits" each.

Based on the Control Symbol Type, these Bits can be Wholes or Parts (integer, fraction), have a leading or scoped Container alignment, or be a Differencing (equal Halfs) or binary 2^n Accumulation.

<H2>Counting Numbers</H2>

All numbers are inclusive like the included collections of bits  [0i..5i] in STFU7 "STFU8" or [0i..13i] in STFUf
such as for(i=0;i<=5;i++) or while(i>=0){i--}

Leading (first) bit is most significant.

Counts are 0i Inclusive [0 to 0i] iterator.

<script type="text/javascript">

var x = new Array();
x[0] = new Array();//0..9a..zA..Z_-
x[1] = new Array();//#
x[2] = new Array();//[#ascii]
x[3] = new Array();//#
x[4] = [
[[48,10,0],[97,26,10],[65,26,36],[95,1,62],[45,1,63]],
[

// These are explicitly mapped, not | 2x01
33,35,36,38,39,40,41,42,43,44,46,47,59,61,63,64,126,10,
33,39,40,41,42,46,126,10
]
];

for(n=0;n<x[4][0].length;n++)
{
	for(v=0;v<x[4][0][n][1];v++)
	{
		PutNumbs(v+x[4][0][n][2],v+x[4][0][n][0]);
	}
}

for(n=0;n<x[4][1].length;n++)
{
	PutNumbs((x[4][1][n] | parseInt("01000000", 2)),x[4][1][n]);
}

function PutNumbs(a,b){
	x[0][a]=String.fromCharCode(b);
	x[1][a]=b;
	x[2][String.fromCharCode(b)]=a;
	x[3][b]=a;
}

function NSix(n,count,offset){
	var s ="";
	for (var i=offset;i<=count;i++)
		//s=x[0][(n>>(6*i))&0x3f] + s;
		s=x[0][(n & (0x3f << (i*6)))>>(i*6)] + s;
	return s;
}

function SixN(s,count,offset){
	var t=0;
	for (var i=offset;i<=count;i++)
		t= t | (x[3][s.charCodeAt(count-i)]<<(6*i) );
	return t;
}

function SixT(s){
	return ( Math.pow(2,10) * SixN(s,5,0) );
}

function TSix(t){
	return NSix(t/Math.pow(2,10),5,0);
}

function TSixNow()
{
document.write(TSix(new Date().getTime()));
}

//document.write("<hr> "+TSix(new Date().getTime()) +"<hr>");
//document.write("<hr> "+SixT(TSix(new Date().getTime())) +"<hr>");


function SpewChars()
{
for(o=0;o<x.length-1;o++)
{
document.write("<br>x["+o+"] = [");
for(q=0;q<x[o].length;q++)
{
if(x[o][q])
document.write(x[o][q]);
if(q!=x[o].length-1)document.write(",");
}
document.write("];");
}
}




//expand these to 8, option of next Expander (to 63i)

//into byte[].

 function char2utf8(input) {
    var output = "";

    for (var n = 0; n < input.length; n++) {
        var c = input.charCodeAt(n);

        if (c < 128) {
output += String.fromCharCode( (c>>6) | parseInt("11000000", 2));
output += String.fromCharCode( (c & 63) | parseInt("10000000", 2));
//String.fromCharCode(c);

//these are the same, crop 127, use sequential 8 = 42b

        } else if ((c > 127) && (c < 2048)) {
            output += String.fromCharCode((c >> 6) | 192);
            output += String.fromCharCode((c & 63) | 128);
        } else {
            output += String.fromCharCode((c >> 12) | 224);
            output += String.fromCharCode(((c >> 6) & 63) | 128);
            output += String.fromCharCode((c & 63) | 128);
        }
//through all 8
    }
    return output;
}

  function utf82char(input) {
    var output = "", i = 0, c = c1 = c2 = 0;

    while (i < input.length) {
        c = input.charCodeAt(i);

        if (c < 128) {
//stick control symbols here
            output += String.fromCharCode(c);
            i++;

        } else if ((c > 191) && (c < 224)) {
            c2 = input.charCodeAt(i + 1);
            output += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
            i += 2;
        } else {
            c2 = input.charCodeAt(i + 1);
            c3 = input.charCodeAt(i + 2);
            output += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            i += 3;
//and the full length
        }
    }

    return output;
}

function checkSTFU8(s,radix,decorate)
{
var ss = "";

for (var n = 0; n < s.length; n++) 
        ss += " " + s.charCodeAt(n).toString(radix);
//s.charCodeAt(n);

return ss;
}

function char2bits(s){
return " STFU8: " + checkSTFU8(char2utf8(s), 2, 0);
}

function FormatSTFU8(){} //put this Back into STFU8 Standard Declarations

</script>


<H2>All Characters are in Expanders.</H2>

ALL "letters" or symbols "character" are encoded in STFU.

(These include the old "ascii" <= 127. All of them are encoded in Expanders. 
Control Symbols are NOT "text" in 01x*
Collections of bits are packed in 00x*)

110xxxxx 10xxxxxx in STFU8

110xxxxx xxxxxxxx  10xxxxxx xxxxxxxx in STFUf

For example: <script>var s = 'a';document.write(s + " or " +  s.charCodeAt(0).toString(2) + " is:" + char2bits(s));</script>

Or letter '0' should actually be zero?
<script>var s = '0';document.write(s + " or " +  s.charCodeAt(0).toString(2) + " is:" + char2bits(s));</script>

Otherwise these aren't  
<script>var s = "'Numbers'";document.write(s + " :" + char2bits(s));</script>

<H2>STFU in TEXT to STFU Accurately:</H2>
The simple STFU @(@) Context in text can be converted to Standard STFU easily!

Bits in text are represented as 63i Symbols (from "ascii"). In STFU, bits are packed as bits.

0123456789
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZ
_-

The "64" Numbers and Control Symbols are mapped from "ascii" of the corresponding "character".

Control Symbols in the text, namely @(') !(') and some others *() ~() .() are converted to the more effective STFU when validated. !'()*.~ 

Everything else, both "UTF" and "ascii", are packed in STFU Expanders.

<H3>...</H3>
<H3>Fluffy Expander:</H3>
This "Fluffy" Expander example handles packing and unpacking of the STFU* variable length encoding.

See the STFUjs on how to form or read @(@) Contexts in texts accurately.





<H2>...</H2>

<H2>...</H2>
<H2>...</H2>
<H2>...</H2>



<h3>Bits in Headers</h3>
<small>
As a courtesy, STFU can include "STFU(*)" headers and sometimes prefixes files with "UTF8" BOM. (Never "UTF16")

The size of the Wraps, Packed Bits, Expander, and STFUx blocks
is indicated with a 63i ascii text header.

STFU(0) is UTF8/ascii "text", the leading bytes are: efbbef0a535456552830290a0a0a0a0a
The STFU is "text" @(@) or !()() in 8-bit bytes.

STFU* (including "STFU8") is <b>formally structured</b> and exhaustive:

The first 16 bytes indicate the scope of the symbol, padded with 0x0a \n.

In any scope STFU*, the header and size is "STFU( )" with the value in 63i max 4×63i ascii in "()".

Any STFU* including "STFU8" STFU(7) or "STFU16" STFU(f) first 16 bytes *can* be
STFU(7):
efbbef0a535456552837290a0a0a0a0a
BOM\nSTFU(7)\n\n\n\n\n
or
STFU(f):
0a0a0a0a5354565528662928xxxx290a
\n\n\n\nSTFU(f)\n\n\n\n\n

STFU Arbitrary bit scope STFU({scope in 63i to ×4})
\ef\bb\ef\nSTFU(7)\n\n\n\n\n in "STFU8"
\n\n\n\nSTFU(f)\n\n\n\n\n in "STFU16"
STFU(u or v?)\n\n\n\n\n 31i "32-bit"
STFU(-)\n\n\n\n\n 63i "64-bit"
STFU(1-)\n\n\n\n 127i "128-bit"
STFU(----)\n\n typical max 64^4 = 2^24 bit scope.

Never STFU(-----)\n is irrational 63i^4i 1 billion bits or 134 MBytes each "character".

STFUx(7) is intentionally misaligned to force the correct process.
efbbef0a53545655782837290a0a0a0a

STFUx(----)\n allows raw binary content within a control Wrap but requires sequential offset processing in the first iteration, NOT parallel. For example STFUx(--) w/ {2×63i=4k bits} block size in bits, but the first wrap is 512 bytes...

STFUx() contains raw bits and shall not be incorrectly read.

</small>


<H1>outdated text</H1>
---
<H3>Expanders & UTF8</H3>

All 8-bit Byte Expanders are available:

len byte[0]  byte[1]  byte[2]  byte[3] ...

"UTF8":

2 [10i]    110xxxxx 10xxxxxx
3 [15i]    1110xxxx 10xxxxxx 10xxxxxx
4 [20i]    11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

<B>The "Books" above 2^23i include the "UTF" in slot 0
and the forms, layout, tooling, phonemes,
and properly sorted "Code Points"; 11111000 is "UTF"</b>

5 [25i] 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
6 [30i] 1111110x + 5× 10xxxxxx
7 [35i] 11111110 + 6× 10xxxxxx
8 [41i] 11111111 + 7× 10xxxxxx + Another Expander

---
<H1>Symbol Tables</H1>

For any Symbol Table: A Control Symbol or Chracter $

$(index)

$(number'{utf8|$()|Number}'index'tree)(v)

or

$({Any Expanders})

$({Any Expanders}'iNd3X'{Any Expanders}'TreE)

But not mixed in any Turn.

<H2>Turns & Slots</H2>

The entire system is based on a Control Symbol (sometimes with a initial time slice), a sequence of Turns through a route "tree", a matching composite value, and compositions of sets in Slots. 


$(turn'turn)({any})
With time: $<script>TSixNow();</script>(turn'turn)({any})

In any of these, both the Turns and Slots, a STFU8 or UTF8 "text", a Context @(@) or !() or a Reference with Associative, an indexed tree ()() and composition, a *() "type" Declaration or a System ~(bits) can be included. A Number can be used as a Turn, as can a STFU8 or UTF8, even a turned reference Context!

Or a set (') of any of them in Slots with or without the Turn index named. [N] if not ()()


<H2>Adding Time:</H2>

The initial time slice can be included for temporal versioning,
it's associated references per referenced initial time as well.

Numbers are 6-bit, the initial time slice is msb aligned to resolution.

$() and $()()
<!--
Plus 4×6=24 bit time:

$<script>TFourNow();</script>() and $<script>TFourNow();</script>()()
-->

Plus 6×6 bit Time:

$<script>TSixNow();</script>() and $<script>TSixNow();</script>()()

The time comes from a chopped 64b time, called "Fone"

The Fone's time is chopped to 2^10 ms, slightly more than one clock second, 65 Fone Seconds, and 6 bit multiples. A short Fone slice is Fone Minutes or Fone Hours, to 64× each.




---
<H1>HTTP Bytes</H1>

There is a compatibility mode for HTTP
using the old "ascii" characters as control symbols and numbers:

<script>
for (
var i = 0;
i <= 255;
i = i + 1
)
{
var s = String.fromCharCode(i);
if (
s == encodeURI(s)
&&
s == encodeURIComponent(s)
)
document.write(s);
}
</script>

Out of:

<script>
for (
var i = 0;
i <= 255;
i = i + 1
)
{
var s = String.fromCharCode(i);
if (
s == encodeURI(s)
)
document.write(s);
}
</script>

Thereby:

$(Index'Tr3E)(v)

---

For @ and !, the Universal Contexts:

@<script>TSixNow();</script>(Context'tree@host.tld)(😴) is an Associative Reference 
@<script>TSixNow();</script>(Context'tree@host.tld) is the Context (and "file" name!)
@<script>TSixNow();</script>(Context'tree@host.tld)() is the References "file"!

Same for !() and !()()

Or without time:

@(Context'tree@host.tld)
@(Context'tree@host.tld)()

These are the URI IRI URL "file name" or reference. at host.tld's interface, as declared in "/@(@host.tld)" or "/@()" "file" via host.tld

<!--
\n
(
~
(index'Tree)(v)
)
\n

!'()*-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~

Out of:

 !#$&'()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~ 

-->

---

<H1>Transport Syntax</H1>

HTTP and IRI (URI, URL) "% encode" everything except:

POST:

!'()*-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~

GET & HEAD:

 !#$&'()*+,-./0123456789:;=?@ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz~ 

Of the available "ascii characters", 

<H2>63i Numbers:</H2>

0123456789
abcdefghijklmnopqrstuvwxyz
ABCDEFGHIJKLMNOPQRSTUVWXYZ_-

<H2>Control Symbols:</H2>

Per the available Symbols from HTTP the Syntax is $(')()

# breaks in "IRI"
$ breaks in PHP, etc
? & = ; break POST & GET
* and : break in file systems
/ is IRI Path
punycode has mutilated -
and social media misuses _


POST:

!'()*.~

GET:

 !#$&'()*+,-./:;=?@~

Available for HTTP Transport:

!'(),.;@~

And POST:

!'().~

The containing Symbols ( "leading hand" and ) "other hand"
combine with the ' as $((')(')'()())() 
to form (iNd3x'Turns) with (index)(Slots).

These Numbers, Control Symbols, or Expanders (including "UTF8")
provide the tree's Turns and the set's Slots.

<H2>Numbers & Control Symbols:</H2>
<small><script>SpewChars();</script></small>


---
<H1>Universal Structure:</H1>


<H2>Structure:</H2>

A local, universal, context, and system table are each required:

~ System
! Universal
.() Local
@ Context

The system table is explicitly reserved for host implementations but includes the minimal standards for operation.

The ! Universal Context is well-formed and extensible by any !() or the abbreviated @(@).

ALL character encodings including those < 128
use Expanders of 2 or more octets with high bit set.

The 64 numbers are 01xxxxxx in STFU and mapped to ascii in the initial encoding of STFU "text".

The @(@) Context is a combination of the context tree and the supporting "named" host.

@(@) are typically a "UTF8" Expander or 6-bit number (or null) indicating the primary context,
@(🐩
then the optional context's tree with '
@(🐩'😎'345'A'🦓
The @ Context delimiter
@(🐩'😎'345'A'🦓@
and the UTF8 Expander
@(🐩'😎'345'A'🦓@stfu.site
that can also have an "IRI" (URI, URL) styled path
@(🐩'😎'345'A'🦓@stfu.site/demo.php/
or fully formed "IRI" in "UTF8" 2+ Byte Expander
@(🐩'😎'345'A'🦓@https://stfu.site/demo.pho?x=
Closed with the ) other containing control symbol
@(🐩'😎'345'A'🦓@stfu.site)

Because ALL characters are "UTF8" Expanders, there are no " quotes or other convolutions.

The "named" host assumes TLD, but can be any system type. ~(demo'tel'sms)(1'000'000'0000)

<H2>Where you at?</H2>

For @ and !, the Universal Contexts:

@<script>TSixNow();</script>(Context'tree@host.tld)(😴) is an Associative Reference

@<script>TSixNow();</script>(Context'tree@host.tld) is the Context (and "file" name!)

@<script>TSixNow();</script>(Context'tree@host.tld)() is the References "file"!

Same for !() and !()()

Or without time:

@(Context'tree@host.tld)
@(Context'tree@host.tld)()

These are the URI IRI URL "file name" or reference. at host.tld's interface, as declared in "/@(@host.tld)" or "/@()' "file" via host.tld

<H2>Local Context:</H2>

Within a Context, indicated by the Tree of Turns,
there is content within:

@(🐩'😎'345'A'🦓.(some'thing)@stfu.site)

The ' and . are handled the same as ~ and !
.(local'tree), though ' is exclusively Turns or Slots in sets. ( starts a turn or set of slots. Implied " (' ".

This Turn, .() indicates the next turns are inside the container or box.

!(~(wire)(~(bits)('''))'(in'set)'@(a@b)'🤣.(3'🤗))

Because @(@) is a courtesy wrapper for !()(),
Both @(@) Context and all of the structures anywhere have the Turn Tree and the value.

In .(local'data)(this pair is a value, here it's an Expander)

The ' of Turns also functions the same way, allowing an in'set turn.

In any level, the ()((local'data)(value))

Or as a set of Slots:

()((local'data)(value)'RAW '(STFU8'UTF8)' in 2×8b or 10xxxxxxs '(local'STFU8'data'4)(value)'etc8s)

The @(@) Context and !() are the same way:

@(@)((local'data)(value))

Or more importantly

@(demo's0me'TrEe@stfu.site)(@(jack@twitter.com)(🤐))

Associative Reference!

This can map an @(@) or !() with the Associative Reference, typically a formally structured Syntax or an Expander suitable for the concept of inter-contextual association.

Internally at any level, any element in the tree can be associated to anything else:

.(local'data)(@(demo@stfu.site)(🤬))

Or

@(demo@stfu.site)(@(demo's0me'TrEe@stfu.site)(🤪))

Or between specific data points inside the box:

@(🐩'😎'345'A'🦓.(some'thing)@stfu.site)(@(demo's0me'TrEe.(local'data)@stfu.site)(🤯))

Simple!

@(demo's0me'TrEe.(local'data)@stfu.site)(@(🐩'😎'345'A'🦓.(some'thing)@stfu.site)(😜))


---
<H1>Associative Reference</H1>

Like the pair of @(@)(🤗) associations, any point in any context can have inter-related associations with any other, anywhere.

In !()() this is called "Cube" and "Ball" held leading-hand and other-hand.

The "cube" has a box that holds stuff.

The "ball" is the Universal Context.

Your stuff is in the box, including your concepts of how other stuff is related (or not) anywhere, in the box or far beyond!

Your "cube" has its own "ball" where references from anywhere else are posted for reference. Every "cube" Context does!

Any Associative Reference can have a diversity of attributes. This includes the standard set and any others that you can come up with, including association by another concept in any context.

<H2>Associative Syntax Structure</H2>


---

<H1>Additional Standard Control Symbols:</H1>

@ Context @(@)
! Universal !()()
~ System Tables ~(bits)
.()() And ()() Local data

<H2>Declaration "type" Anywhere!</H2>

*() Declaration "type" anywhere

Any (named'index'🦓)(@(🐩'1am'😴@stfu.site)(😜🤯🤪)) can include an Associative Reference with it's own type!

.(named'index'🦓)(@(🐩'1am'😴@stfu.site)(*(@(😋'types'associative'😍@stfu.site)'
(😍'value)(3)'(😍'type)(🤯)
))


Is an easy example of a Declared *() "type" using named index values for Accurate Representation!

Any structure of knowledge or concepts can be represented and presented this way using the Declaration's referenced "show" "cube" "ball" "flow" and related definitions.

<H2>,() "Alternate Text" ~(hint)</H2>

At any level of Slots (except Turns), 
" ,() " can be included as an alternate "hint" (typically a short text name or description), and "overload" values set in YOUR reference to another context, such as changing the color of a tooling in the "cube" when using their layout process.

<H2>IRI Reference from ~(bits)</H2>

/() is included for IRI URI URL reference from a definition in the #Declaration *() on how to use those ~(bits). Typically the description exhaustively describes the structure (image).

---
<H1>Declaration Conditions</H1>

The entire system uses one standard format and one *() Declaration that includes the "host" Implementation getting and setting bits. 

Containers of bits referenced in the host have their Declared structure and describe their processes or configuration therein.

Valid "host" Implementations might extend a more direct physical process, like an ADD function of a Declared fixed bit width or "glsl" triangles into "show" or "flow". (Pixels)

<H2>Merging Structures</H2>

Multiples shall be handled as parallel records such as [a,b] of the same but different; many Associative References exist between the same Concepts, and similar Contexts may merge in presentation!

---

<H1>Declaration + "type"</H1>

The Control Symbol *() is the Declaration.

The Declaration either contains the definition of the structure or contains a reference to a Context that Declares the type's structure.

The Declaration *() can contain the entire definition and how to correctly present your concepts or context anywhere!

All structure, and all operation (such as the representation of your "cube" and "ball" and how to "show" them) are defined in the Declaration *()

The host Implementation need only a minimally simple and formally valid ability to copy bits to various "wire" or "line" interfaces including screen pixels, phone or Internet connectivity, or the host's memory.

The system in whole uses a "Table Basher" that is formally valid everywhere and collections of ~(bits) and *(structures) that you define.

There is a minimal or host implementation augmented set of "Truth Tables". ~(true) And logic "flow".

The *() includes everything necessary to calculate the Accurate Representation of your Context, Concepts, and Associated References and "show" them any way you want!

There is a Declaration of how to "show" your Context, including how to Accurately Represent your "cube" and "ball", and inter-associated concepts beyond your "ball" in the "show"!

Every Context has a cube and a ball, at every level.

The cube has stuff in a box, the ball has the Universe.

The cube has its own ball! Infinitely many cubes and balls inside each little Context (but preferably each general concept in it's own context) STFU!

The type Declaration * takes care of everything else!

<H2>Truth, Logic, FLOW</H2>

The elementary logic, presentation, data representation, ... and flow control are all contained in the System Table.

All you really need is the ability to copy bits between some place to another, at any scale.

By using bits and containers of bits with only a minimal get&set function, every Context controls the entire process of Accurately representing it's data and presentation!

<H2>SHOW CUBE BALL</H2>

Every context, at any level, is provided a "cube" to Accurately represent it's stuff.

Within the 4D cube, a 3D volume and time, you can represent your STFU any way you could possibly want!

Animation, 3d objects and tooling, human interaction, layout graphemes or audible phonemes, etc. You have explicit control of how your context is represented!

The "show" and it's "flow" in the *() Declaration describes how your concepts are presented in your "cube", how data from your STFU boxes are represented, and how Associative References in your cube or from it's ball are presented.

Beyond your "cube" at any level is a "ball" that includes the Contexts and Associative References for the entire universe.

Your *() Declaration's "show" handles ALL of the layout and presentation for your Concepts and Contexts anywhere they go, and do exactly the same for every STFU Context that gets to you!

<H2>Declaration Efficiency, Burdon</H2>

The Declaration *() includes an overview of the technical processes of presentation including controls for efficiency, complexity, detail, and the description of how to Accurately Represent the Concepts in the best way for anyone.

Everything goes in a "cube" or controlled by a "ball"!


<H2>Declaration's in Contexts</H2>

Every Context has a Declaration of it's structure and how to Accurately present it.

Any specific data can include it's own unique "show" or "type" or it can reference a Context *(*(@(@))) somewhere that describes a way you prefer.

Multiple ways are merged for the most correct representation possible!


<H2>FLOW & control</H2>

Every process related to your Context is controlled entirely by your description in the *() Declaration.

The entire system does nothing other than move bits around and tell the host Implementation to put bits as pixels on a screen or put bits to wire and get some more! (Any wire, audio, video, interfaces, camera, phone or Internet, or as a host for the data!)

Extensions of the bit operations in formally valid implementations make Accurate Representation and presentation very fast and efficient!

Entire complexities of process can be implemented in your Context with the "show" "cube" "ball" "flow" in the *() Declaration.

The template that shows this structure and Accurately Represents these Concepts is simply a set of descriptions in the Declaration that request the valid implementations "host" to move bits around to various places ALSO described by a Declaration in a Context.

Anywhere!


---

<H1>Initial Time + Re-Visioning</H1>

Accuracy of Representation is important. When you reference something you expect it to be accurate, not randomly changed into something else.

Control codes for previous & next allow the sequence in time to be loaded together.

A context could change to someone else, or become outdated.

@<script>TSixNow();</script>(@) or @<script>TSixNow();</script>(@)
!<script>TSixNow();</script>(...)

allows for a n×6 bit initial time slice to be indicated, providing versioning and history and the References to it can be stored on the local time slice as well. msb aligned

@<script>TSixNow();</script>(@)() ALL THE REFERENCES!

It's better to create a new timeslice or tree'd Context when things change, keeping the other ones because someone somewhere else might reference them!





---

<H1>Tools of Implementation</H1>

In order for your Concepts and References to be Accurately Represented, you need to use 


This can be loaded and referenced accurately in parallel starting at any point using an expanding tree or linked-list that has offsets.

Because the Control Symbols and Numbers are never STFU8 "text" nor UTF8, they will always be accurate.

A \n newline is processed similar to the ' but only between 

The Context "file" @(@) has everything in this simple box.

Your Accurate Representation is shown in a "cube" with all your local references and any local references to anything else!

The Associated References "Ball" @(@)() "file" has ALL of the references to it from anywhere else and is open-ended so it can be appended.

Same for !() and !()() 

---

<H1>Formal Syntax</H1>

Bit-Sequential processing tree with parallel offsets and optional alignments

.()(@(.()@)) expands inline.
()()' vs .()() locals

---

<H1></H1>

---

<H1></H1>

---

<H1></H1>

---


<H1></H1>

---


